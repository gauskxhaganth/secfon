# BAGIAN I
## Pengantar Blockchain Ethereum

Buku ini berfokus secara spesifik untuk membantu Anda belajar mengembangkan *smart contract* di Ethereum. Fokus ini mengharuskan kita untuk membahas sebagian dari protokol Ethereum, bahasa pemrograman Solidity, dan Ethereum Virtual Machine. Untuk pemahaman yang lebih mendalam dan komprehensif tentang Ethereum, kami merekomendasikan buku *Mastering Ethereum* oleh Andreas M. Antonopoulos dan Gavin Wood. Meskipun begitu, agar dapat mengembangkan *smart contract* secara efektif, sangat penting bagi Anda untuk memahami konsep-konsep dasar *smart contract* tertentu. Kami akan membahas konsep-konsep tersebut dengan detail yang sekadarnya agar kita tidak membuang waktu dan Anda bisa segera masuk ke mode membangun (*builder mode*). Kami ingin Anda segera men-*deploy* *smart contract* pertama Anda sesegera mungkin. Kami tahu pendekatan ini adalah cara yang paling andal bagi orang-orang untuk mempelajari teknologi baru.

---

# BAB 1
## Konsep-Konsep Blockchain

Pada dasarnya, **blockchain** adalah sebuah struktur data. Ia adalah sebuah *linked list*, atau rantai, dari “blok-blok” yang unik. Setiap blok menunjuk ke blok sebelumnya, dan blok itu sendiri merupakan sebuah daftar transaksi. Di atas struktur data daftar-di-dalam-daftar yang relatif sederhana ini, diletakkan inovasi kunci yang diberikan oleh *blockchain*: sebuah protokol tentang bagaimana blok ditambahkan ke dalam rantai tanpa adanya otoritas pusat. Gambar 1-1 mengilustrasikan struktur ini.

*Cryptocurrency* yang muncul bersama *blockchain* adalah sarana untuk mencapai tujuan, yaitu menyediakan insentif bagi orang-orang untuk menjalankan perangkat lunak yang mengamankan jaringan. Untuk pertama kalinya dalam sejarah, kita memiliki kemampuan untuk berbagi informasi digital tanpa perlu mempercayai individu, pemerintah, organisasi, atau perusahaan mana pun untuk memfasilitasi interaksi tersebut. Ethereum menyediakan platform yang aman secara kriptografis untuk menyimpan, memperbarui, dan menghapus data dari *blockchain* menggunakan apa yang disebut sebagai “*smart contract*”. Kita masih berada di masa-masa awal dalam mempelajari cara menggunakan *smart contract* untuk memperbaiki berbagai hal di dunia nyata, dan sulit untuk memprediksi bagaimana teknologi ini akan digunakan di masa depan. Mirip dengan “World Wide Web” pada tahun 1990-an, telah terjadi gelombang global para pemecah masalah yang inspiratif dan kreatif yang bekerja setiap hari untuk men-*deploy* **aplikasi terdesentralisasi (DApps)** yang mereka harap akan “memberi dampak di alam semesta” (*make a dent in the universe*).

<p align="center">
  <img src="images/books-06-hands-on_smart_contract_development/figure-1.1.png" alt="gambar" width="580"/>
</p>

Sebagian besar isi buku ini akan berfokus pada bahasa pemrograman **Solidity** dan pengembangan *smart contract*. Solidity adalah bahasa pemrograman populer untuk mengembangkan *smart contract*, dan dirancang untuk berjalan di **Ethereum Virtual Machine (EVM)**. Solidity bukanlah bahasa pemrograman pertama yang berjalan di EVM, dan tentunya bukan yang terakhir. Banyak bahasa lain, seperti Vyper, akan ditulis untuk berjalan di EVM, dengan tujuan untuk menyempurnakan desain Solidity atau menyediakan bahasa spesifik-domain (*domain-specific languages*) yang kuat. Sebelum kita mendalami dunia *smart contract* yang revolusioner, kita perlu meletakkan fondasi konseptual untuk Anda bangun. Mengingat sifat unik dari eksekusi kode di *blockchain* secara historis, sangat penting bagi para pengembang untuk memiliki pemahaman yang cukup tentang bagaimana semua bagian saling terhubung di balik abstraksi yang kuat yang disediakan oleh Ethereum.

## Sejarah Singkat 📜

Konsep "blockchain" lahir dari [white paper Bitcoin](https://bitcoin.org/bitcoin.pdf) yang diterbitkan pada tahun 2008 oleh sosok pseudonim **Satoshi Nakamoto**. Meskipun istilah "blockchain" sebenarnya tidak muncul dalam tulisan tersebut, konsepnya diartikulasikan secara ringkas. Transaksi pertukaran nilai masuk ke dalam jaringan *peer-to-peer*, dan secara berkala dikelompokkan ke dalam "blok", atau daftar. Ketika sebuah "blok" transaksi disimpan secara permanen, blok tersebut "dirantai" (*chained*) ke blok sebelumnya. Struktur data yang hanya bisa ditambah (*append-only*) ini dan protokol yang membangunnya menciptakan sebuah catatan transaksi yang tidak dapat diubah (*immutable*).

Peluncuran Bitcoin pada awal 2009 menandai dimulainya jaringan *blockchain* publik. Sejak saat itu, tak terhitung banyaknya *cryptocurrency* yang mencoba membangun di atas kesuksesan Bitcoin sebagai bentuk mata uang baru. Banyak pengguna awal Bitcoin menyadari bahwa properti dari *blockchain* memiliki aplikasi di luar transaksi keuangan. Komunitas-komunitas pun bermunculan untuk mencoba memperluas, melakukan *fork*, dan membangun di atas Bitcoin untuk mengembangkannya ke arah yang sebelumnya tidak terpikirkan. Namun pada akhirnya, protokol Bitcoin sengaja dibuat terbatas dan tidak cocok untuk diperluas. Seorang jenius *blockchain*, **Vitalik Buterin**, membuat keputusan ambisius untuk berhenti mencoba memperluas Bitcoin dan sebaliknya menciptakan protokol yang lebih serbaguna dari awal. Pada tahun 2013, Vitalik menulis [white paper Ethereum](https://github.com/ethereum/wiki/wiki/White-Paper).

Ketika Ethereum diluncurkan pada tahun 2015, ia dengan cepat menjadi salah satu *cryptocurrency* paling berharga di planet ini, nomor dua setelah Bitcoin. Pasar menilai Ethereum sangat berharga karena ia menyediakan sebuah platform untuk men-*deploy* dan menjalankan *smart contract* di *blockchain* publik. Istilah "*smart contract*" diciptakan oleh [Nick Szabo pada tahun 1994]http://bit.ly/szabo-sc. Gagasannya saat itu adalah bahwa banyak kontrak hukum, notaris, dan perjanjian analog lainnya dapat ditegakkan secara nyaris otomatis menggunakan protokol digital dan tanda tangan kriptografis.

Meskipun konteks historis ini ada, implementasi *smart contract* di Ethereum sebenarnya lebih terasa seperti pemrograman serbaguna daripada sesuatu yang spesifik untuk kontrak hukum. Mesin virtual sebagaimana didefinisikan oleh protokol Ethereum adalah ***Turing-complete***. Ini berarti selama Anda dapat menyesuaikan komputasi Anda di dalam batasan dari satu blok tunggal, para pengembang *smart contract* hanya memiliki sedikit batasan lain untuk dihadapi selain imajinasi mereka sendiri.

Bagaimana sebuah *blockchain* berbeda dari teknologi yang mungkin pernah Anda gunakan sebelumnya? Di bagian selanjutnya, mari kita bahas apa yang membuat *blockchain* unik.

## Karakteristik Sebuah Blockchain

Banyak pengembang perangkat lunak pernah bekerja dengan *technology stack* yang mencakup 1) antarmuka pengguna seluler asli dan/atau antarmuka pengguna web 2) dengan bahasa pemrograman sisi server yang pada akhirnya berinteraksi dengan 3) sebuah basis data. Dalam versi paling dasar dari sistem-sistem ini, interaksi dengan basis data pada dasarnya bersifat instan dan permanen.

Seperti basis data yang lebih umum, *blockchain* dapat menyimpan data arbitrer, tetapi keduanya memiliki sedikit kesamaan lain. Menjadi pengembang *smart contract* yang kompeten berarti memahami karakteristik sebuah *blockchain*. Seseorang tidak bisa begitu saja memperlakukan Solidity seperti bahasa pemrograman sisi server; Anda akan cepat merasa tersesat dan frustrasi. Tidak seperti basis data pada umumnya, interaksi bahkan dengan sistem *smart contract* yang paling dasar sekalipun tidaklah instan dan tidak dijamin permanen.

Berbeda dengan basis data biasa, yang merupakan satu program yang berjalan di satu komputer, sebuah **blockchain** biasanya terdiri dari banyak **node** dalam jaringan di seluruh dunia. Ketika kita merujuk pada "node" dalam konteks *blockchain*, kita merujuk pada perangkat lunak yang telah dipasang seseorang di komputer dan terhubung ke jaringan *blockchain*. Sama seperti ada banyak implementasi perangkat lunak yang berbeda dari protokol HTTP (Apache, NGINX) yang disebut "*web server*", ada banyak implementasi perangkat lunak dari protokol Ethereum (geth, Parity) yang disebut node Ethereum.

Selanjutnya, mari kita bahas bagaimana kita dapat menggunakan jaringan untuk terhubung dengan *blockchain*.

## Jaringan Terdesentralisasi

Untuk bekerja dengan basis data biasa, kita memerlukan koneksi basis data dan hak yang cukup untuk memperbaruinya. Dalam kasus yang paling sederhana, hanya ada satu basis data yang harus dihadapi, jadi kita memerlukan satu alamat IP untuk membuat koneksi. Seluruh sistem bergantung pada ketersediaan basis data tersebut. Jika basis data itu rusak atau kehilangan konektivitas, atau jika hak kita dicabut, aplikasi akan berhenti bekerja. Inilah yang disebut sebagai **sistem terpusat**.

*Blockchain* dirancang untuk berjalan di atas **jaringan terdesentralisasi**. Orang-orang dan perusahaan menjalankan node di jaringan, dan, dalam banyak hal, semua node adalah rekan sejawat (*peers*). Hal ini dimungkinkan karena setiap node berisi riwayat lengkap dari setiap transaksi yang pernah terjadi di *blockchain*. Dengan setiap node sebagai entitas yang mandiri dan independen, tidak ada pusat di jaringan tersebut. Semua node memvalidasi transaksi dan menyebarkannya ke rekan-rekan mereka. Di atas semua itu, beberapa node juga berpartisipasi dalam proses pembuatan blok, dan diberi insentif finansial untuk melakukannya melalui penerimaan "*block reward*" dalam *cryptocurrency* asli *blockchain* tersebut. Berbeda dengan contoh basis data kita, node mana pun dalam jaringan terdesentralisasi dapat bergabung atau keluar sesuka hati. Tidak ada izin atau hak khusus yang diperlukan untuk membaca atau menulis ke *blockchain* selama protokolnya diikuti.

Tanpa adanya basis data tunggal yang terpusat untuk dihubungkan, bagaimana node menemukan koneksi ke jaringan? Banyak pengembang *smart contract* menghindari masalah ini dan menggunakan layanan yang menyembunyikan kompleksitas ini di balik API web. Itu adalah sebuah pertukaran (*tradeoff*) antara mengaitkan sistem Anda dengan layanan pihak ketiga dan kompleksitas menjalankan node Ethereum Anda sendiri. Jika Anda memilih untuk menjalankan node Anda sendiri, ia perlu melakukan *bootstrap* dan terhubung ke jaringan Ethereum publik. Setiap perangkat lunak node Ethereum utama memiliki daftar "*bootnode*" yang sudah di-*hardcode*. Ini adalah alamat-alamat IP yang terkenal dan relatif andal yang dapat digunakan untuk membuat kumpulan koneksi rekan jaringan yang cukup besar. Jika karena suatu alasan node-node tersebut tidak tersedia atau tidak lagi dapat dipercaya, perangkat lunak node dapat diberikan daftar *bootnode* kustom untuk digunakan.

Pada tahun 2019, jaringan Ethereum publik global memiliki lebih banyak node daripada jaringan *blockchain* lainnya. Dengan lebih dari 12.000 node, kecil kemungkinannya ada dua node yang memiliki himpunan rekan yang sama persis. Saat sebuah transaksi masuk ke jaringan melalui satu rekan, transaksi itu menyebar dengan cepat ke seluruh dunia ke setiap node. Demikian pula, ketika sebuah blok baru ditambahkan ke *blockchain*, berita tentang penambahan ini menyebar dengan cepat. Sayangnya, cepat tidak sama dengan instan, yang berarti bahwa ketika dua blok dibuat pada saat yang sama oleh dua node yang berbeda, rekan-rekan masing-masing dari node yang berbeda itu akan beroperasi pada dua versi *blockchain* yang berbeda. Ini disebut ***fork* sementara**. Secara umum, *fork* sementara diselesaikan dengan memberikan prioritas kepada *fork* mana pun yang menambahkan blok berikutnya, yang diringkas sebagai "**rantai terpanjang yang menang**" (*longest chain wins*). Aturan-aturan ini ditentukan oleh protokol konsensus sebuah *blockchain*.

## Protokol Konsensus 🤝

Tanpa sumber kebenaran yang terpusat, node-node dalam jaringan *blockchain* memerlukan cara untuk mencapai konsensus mengenai keadaan sistem. **Protokol konsensus** adalah cara hal ini dicapai, dan merupakan bidang penelitian yang aktif. Protokol konsensus hanyalah sebuah sistem kesepakatan di seluruh *blockchain*. Ada tiga protokol yang perlu kita bahas, dan kita akan mulai dengan **Proof-of-Work**, yang digunakan Ethereum saat mereka meluncurkan *blockchain* mereka.

### Proof-of-Work

Ketika Anda mendengar tentang "*mining ether*" atau "*cryptomining*", terminologi ini disebabkan oleh sifat protokol **Proof-of-Work (PoW)**. Seperti seorang penambang yang mencari emas, protokol PoW untuk membuat sebuah blok memerlukan upaya yang cukup besar, dan semakin banyak upaya yang Anda keluarkan, semakin besar kemungkinan Anda untuk "menambang sebuah blok". Juga mirip dengan penambang yang mencari emas, "penambangan" PoW bersifat kompetitif. Setiap blok Ethereum berisi hadiah blok (*block reward*) dalam mata uang Ethereum, yang dikenal sebagai "*ether*". Hadiah ini diberikan kepada penambang yang berhasil menambahkan blok yang valid ke *blockchain* sebelum penambang lainnya. Penambang berhasil dengan cara melakukan "*hashing*" data blok secara berurutan dalam upaya menemukan *hash* kriptografis yang memiliki karakteristik spesifik. Protokol menentukan kelangkaan "*hash*" ini. Kelangkaan ini disebut "***difficulty***", yaitu angka yang menentukan upaya relatif yang harus dikeluarkan penambang untuk "menambang sebuah blok".

Proof-of-Work menggunakan variabel *difficulty* untuk mempertahankan waktu blok (*block time*) yang stabil saat penambang datang dan pergi, menambah atau mengurangi kekuatan penambangan keseluruhan (atau ***hashrate***) jaringan. Misalnya, jika jaringan Ethereum memiliki *hashrate* kumulatif 100 tera hash per detik, dan sebuah *mining pool* besar *offline*, menurunkan *hashrate* kumulatif menjadi 90 TH/s, blok tiba-tiba akan memakan waktu rata-rata 10% lebih lama untuk ditambang. Protokol Ethereum menyesuaikan *difficulty* untuk memastikan bahwa waktu blok yang benar ditargetkan. Dalam kasus ini, protokol akan menyesuaikan dengan membuat penemuan blok sekitar 10% lebih mudah. Proses ini berarti bahwa jika terjadi perubahan signifikan pada *hashrate* jaringan, waktu blok akan terpengaruh. Selain itu, karena sifat proses penambangan yang bersifat *brute-force*, keacakan akan selalu menjadi sumber perbedaan dalam waktu blok, bahkan jika *hashrate* jaringan tetap konstan.

### Proof-of-Stake

**Proof-of-Stake (PoS)** selalu ada dalam peta jalan (*roadmap*) Ethereum. Jika dirancang dengan benar, PoS memiliki keuntungan signifikan dibandingkan PoW. Pertama, tidak perlu membakar sejumlah besar listrik untuk menemukan blok yang valid. Seperti namanya, tidak ada "pekerjaan" (*work*) yang harus dilakukan, hanya "taruhan" (*stake*) yang bisa hilang. Kedua, kerugian menjadi pelaku jahat dalam sistem PoS bisa jauh lebih parah daripada di PoW. Pembuat blok mempertaruhkan (*stake*) ether untuk berpartisipasi, dan jika mereka terbukti beroperasi dengan niat jahat, taruhan itu dapat diambil ("di-*slashed*"). Di PoW, operator jahat dapat diabaikan, tetapi kita tidak dapat mengambil perangkat keras mereka. Aset itu tetap ada untuk merusak di lain hari. Terakhir, ada lebih sedikit skala ekonomi di PoS. Ketika seorang penambang PoW mendapatkan hadiah blok, mereka dapat menggunakan uang itu untuk mencapai keuntungan non-linear atas penambang lain, seperti konektivitas jaringan yang lebih cepat. Di PoS, meskipun orang dengan taruhan lebih banyak akan mendapatkan lebih banyak ether, keuntungan itu bersifat linear. Yang kaya tetap menjadi lebih kaya, tetapi tidak secara eksponensial. Meskipun begitu, di PoW untuk mendapatkan mata uang, Anda dapat membeli perangkat keras dan terhubung ke jaringan, sedangkan di PoS Anda harus membeli dari pemegang mata uang yang ada, yang memberikan kerugian bagi pendatang baru.

Bagi pengembang *smart contract*, perilaku PoS mirip dengan PoW. Kita masih perlu menentukan kapan kita menganggap finalitas transaksi, karena pembuat blok (disebut "*proposer*" di PoS) masih bisa berakhir di *fork* yang berbeda karena partisi jaringan. Hal yang akan menjadi sangat berbeda adalah ketika Ethereum bertransisi ke *blockchain* yang di-*shard* (*sharded*). Di bawah nama proyek "**Serenity**", Ethereum memperkenalkan Proof-of-Stake, *sharding*, dan beberapa perbaikan lainnya sebagai cara untuk menyelesaikan masalah penskalaan fundamental Ethereum.¹ Serenity juga akan menggantikan EVM yang ada dengan **eWASM** (*Ethereum flavored WebAssembly*). Tidak ada dari inisiatif ini yang seharusnya memiliki efek signifikan pada bahasa Solidity. Satu-satunya komplikasi baru yang signifikan adalah komunikasi antar-kontrak. Saat ini, setiap node memiliki setiap *smart contract* Ethereum yang pernah di-*deploy*, jadi cukup mudah bagi node untuk berinteraksi. Tetapi begitu kita memiliki *blockchain* yang di-*shard*, kontrak akan tersebar di 1000+ *blockchain* terpisah. Protokol tentang bagaimana kontrak-kontrak ini akan berinteraksi masih sedang dikembangkan, tetapi dapat dipastikan bahwa pengembang *smart contract* tidak akan lagi dapat mengasumsikan bahwa kontrak arbitrer mana pun akan tersedia bagi mereka secara sinkron. Lebih jauh lagi, setiap alamat Ethereum perlu memiliki ID *shard* yang terkait dengannya untuk mengetahui di mana statusnya disimpan.

### Proof-of-Authority

Dalam beberapa situasi, mungkin masuk akal untuk menggunakan *blockchain* sambil membatasi pembuatan blok hanya untuk entitas tertentu. Situasi-situasi ini bertentangan dengan kasus penggunaan umum yang terbuka untuk publik. Status pembuat blok yang dibatasi semacam ini disediakan oleh protokol **Proof-of-Authority (PoA)**. PoA umumnya digunakan untuk *blockchain* pribadi yang tersembunyi di dalam jaringan internal. Para pembuat blok hanya bergiliran menambahkan blok berikutnya pada frekuensi yang benar. Karena sifat *round-robin* dari PoA, *fork* sementara jauh lebih kecil kemungkinannya terjadi.

Ada banyak lagi protokol konsensus, tetapi itu di luar cakupan buku ini. Ini adalah area penelitian yang aktif, jadi harapkan untuk melihat protokol konsensus baru muncul di tahun-tahun mendatang.

Terlepas dari protokol mana yang digunakan, ada hadiah untuk setiap node yang menambahkan blok baru ke *blockchain*. Pembuat blok menerima hadiah blok serta jumlah semua biaya transaksi di dalam blok tersebut. Di Ethereum, biaya transaksi disebut sebagai "**gas**". Kita akan membahas lebih dalam tentang topik gas nanti di bab ini.

Untuk tujuan buku ini, kita tidak perlu memahami mekanisme protokol konsensus. Penting hanya untuk mengetahui peran yang dimainkan protokol-protokol ini dalam *blockchain*, dan memahami perbedaan antara protokol yang paling populer. Pengembang *smart contract* pada dasarnya dapat memperlakukan protokol konsensus seperti sebuah *black box*. Kita perlu mempelajari perilaku eksternal setiap kotak, tetapi bagian dalamnya tidak berpengaruh pada pekerjaan kita.

Sekarang kita akan berusaha memahami bagaimana transaksi pada akhirnya ditambahkan ke *blockchain*.

## Pemrosesan Transaksi ⚙️

Pada tahun 2019, sebuah blok transaksi baru ditambahkan ke *blockchain* Ethereum kira-kira setiap 13 detik, rata-rata. Meskipun begitu, sampel waktu blok selama rentang 65 jam (antara blok 8.662.243 dan 8.679.755) berisi sebuah blok yang membutuhkan lebih dari 2 menit untuk ditulis ke rantai (blok 8.674.540) dan yang lainnya hanya membutuhkan 1 detik. Variasi waktu blok yang lebar ini disebabkan oleh sifat acak dari Proof-of-Work. Seiring transisi Ethereum ke Proof-of-Stake, kita berharap akan melihat waktu blok dan variabilitas waktu blok menurun.

Meskipun waktu blok diatur oleh protokol, waktu sebenarnya yang dibutuhkan sebuah transaksi, dari saat pertama kali disiarkan di jaringan hingga eksekusinya dalam sebuah blok, dapat bervariasi dari beberapa detik hingga beberapa jam. Variabilitas ini disebabkan oleh keterbatasan protokol Ethereum saat ini yang dikombinasikan dengan popularitasnya. Misalnya, jika Ethereum dapat memproses sekitar 25 transaksi per detik, tetapi ada lebih dari 30 transaksi yang masuk ke jaringan setiap detiknya, maka akan ada transaksi yang tetap tidak dieksekusi sampai permintaan jaringan melambat hingga di bawah 25 transaksi per detik. Transaksi yang tertunda ini disimpan dalam memori oleh setiap node Ethereum dalam apa yang disebut "**mempool**". Cara yang paling andal untuk dengan cepat mengeluarkan transaksi dari *mempool* dan memasukkannya ke dalam blok adalah dengan membayar lebih banyak biaya kepada pembuat blok. Di Ethereum, biaya ini disebut "**gas**", dan sebagai pengembang *smart contract*, Anda harus sering mempertimbangkan "**harga gas**" (*gas prices*). Lihat lebih lanjut tentang topik gas dan harga gas pada Gambar 1-2.

<p align="center">
  <img src="images/books-06-hands-on_smart_contract_development/figure-1.2.png" alt="gambar" width="580"/>
</p>

Jika akun yang sama memiliki dua transaksi di dalam *mempool*, para pembuat blok tahu transaksi mana yang harus dipilih terlebih dahulu berdasarkan “**nonce**”-nya, yaitu sebuah penghitung khusus untuk setiap akun yang nilainya bertambah pada setiap transaksi. Ini berarti bahwa meskipun *mempool* pada umumnya adalah sebuah tumpukan transaksi yang dapat dipilih oleh pembuat blok, sebenarnya ia lebih seperti tumpukan antrean (*a heap of queues*) dalam kasus di mana sebuah akun telah mengirimkan beberapa transaksi sebelum melihatnya berhasil. Gambar 1-3 menunjukkan bagaimana transaksi dari setiap akun diurutkan berdasarkan *nonce*-nya.

<p align="center">
  <img src="images/books-06-hands-on_smart_contract_development/figure-1.3.png" alt="gambar" width="580"/>
</p>

